{"version":3,"sources":["../../../src/test/matchers/toMatchText.ts"],"names":["toMatchText","matcherName","receiver","receiverType","query","expected","options","testInfo","Error","matcherOptions","isNot","promise","test","undefined","printExpected","received","pass","remainingTime","matchSubstring","includes","timeout","_testFinished","stringSubstring","message","indexOf","length","exec","labelExpected","labelReceived","expand"],"mappings":"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","sourcesContent":["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  printReceivedStringContainExpectedResult,\n  printReceivedStringContainExpectedSubstring\n} from 'expect/build/print';\n\nimport {\n  EXPECTED_COLOR,\n  matcherErrorMessage,\n  matcherHint, MatcherHintOptions,\n  printExpected,\n  printWithType,\n  printDiffOrStringify,\n} from 'jest-matcher-utils';\nimport { currentTestInfo } from '../globals';\nimport type { Expect } from '../types';\nimport { expectType, pollUntilDeadline } from '../util';\n\nexport async function toMatchText(\n  this: ReturnType<Expect['getState']>,\n  matcherName: string,\n  receiver: any,\n  receiverType: string,\n  query: (timeout: number) => Promise<string>,\n  expected: string | RegExp,\n  options: { timeout?: number, matchSubstring?: boolean } = {},\n) {\n  const testInfo = currentTestInfo();\n  if (!testInfo)\n    throw new Error(`${matcherName} must be called during the test`);\n  expectType(receiver, receiverType, matcherName);\n\n  const matcherOptions: MatcherHintOptions = {\n    isNot: this.isNot,\n    promise: this.promise,\n  };\n\n  if (\n    !(typeof expected === 'string') &&\n    !(expected && typeof expected.test === 'function')\n  ) {\n    throw new Error(\n        matcherErrorMessage(\n            matcherHint(matcherName, undefined, undefined, matcherOptions),\n            `${EXPECTED_COLOR(\n                'expected',\n            )} value must be a string or regular expression`,\n            printWithType('Expected', expected, printExpected),\n        ),\n    );\n  }\n\n  let received: string;\n  let pass = false;\n\n  // TODO: interrupt on timeout for nice message.\n  await pollUntilDeadline(testInfo, async remainingTime => {\n    received = await query(remainingTime);\n    if (options.matchSubstring)\n      pass = received.includes(expected as string);\n    else if (typeof expected === 'string')\n      pass = received === expected;\n    else\n      pass = expected.test(received);\n\n    return pass === !matcherOptions.isNot;\n  }, options.timeout, testInfo._testFinished);\n\n  const stringSubstring = options.matchSubstring ? 'substring' : 'string';\n  const message = pass\n    ? () =>\n      typeof expected === 'string'\n        ? matcherHint(matcherName, undefined, undefined, matcherOptions) +\n        '\\n\\n' +\n        `Expected ${stringSubstring}: not ${printExpected(expected)}\\n` +\n        `Received string:        ${printReceivedStringContainExpectedSubstring(\n            received,\n            received.indexOf(expected),\n            expected.length,\n        )}`\n        : matcherHint(matcherName, undefined, undefined, matcherOptions) +\n        '\\n\\n' +\n        `Expected pattern: not ${printExpected(expected)}\\n` +\n        `Received string:      ${printReceivedStringContainExpectedResult(\n            received,\n            typeof expected.exec === 'function'\n              ? expected.exec(received)\n              : null,\n        )}`\n    : () => {\n      const labelExpected = `Expected ${typeof expected === 'string' ? stringSubstring : 'pattern'\n      }`;\n      const labelReceived = 'Received string';\n\n      return (\n        matcherHint(matcherName, undefined, undefined, matcherOptions) +\n        '\\n\\n' +\n        printDiffOrStringify(\n            expected,\n            received,\n            labelExpected,\n            labelReceived,\n            this.expand !== false,\n        ));\n    };\n\n  return { message, pass };\n}\n"],"file":"toMatchText.js"}