{"version":3,"sources":["../../src/utils/httpServer.ts"],"names":["HttpServer","constructor","_server","_urlPrefix","_routes","routePrefix","prefix","handler","push","routePath","path","exact","start","port","http","createServer","_onRequest","bind","listen","Promise","cb","once","address","stop","close","urlPrefix","serveFile","response","absoluteFilePath","headers","content","fs","readFileSync","statusCode","contentType","extensionToMime","extname","substring","setHeader","byteLength","name","value","Object","entries","end","e","request","on","url","URL","route","pathname","startsWith"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as http from 'http';\nimport fs from 'fs';\nimport path from 'path';\n\nexport type ServerRouteHandler = (request: http.IncomingMessage, response: http.ServerResponse) => boolean;\n\nexport class HttpServer {\n  private _server: http.Server | undefined;\n  private _urlPrefix: string;\n  private _routes: { prefix?: string, exact?: string, handler: ServerRouteHandler }[] = [];\n\n  constructor() {\n    this._urlPrefix = '';\n  }\n\n  routePrefix(prefix: string, handler: ServerRouteHandler) {\n    this._routes.push({ prefix, handler });\n  }\n\n  routePath(path: string, handler: ServerRouteHandler) {\n    this._routes.push({ exact: path, handler });\n  }\n\n  async start(port?: number): Promise<string> {\n    this._server = http.createServer(this._onRequest.bind(this));\n    this._server.listen(port);\n    await new Promise(cb => this._server!.once('listening', cb));\n    const address = this._server.address();\n    this._urlPrefix = typeof address === 'string' ? address : `http://127.0.0.1:${address.port}`;\n    return this._urlPrefix;\n  }\n\n  async stop() {\n    await new Promise(cb => this._server!.close(cb));\n  }\n\n  urlPrefix() {\n    return this._urlPrefix;\n  }\n\n  serveFile(response: http.ServerResponse, absoluteFilePath: string, headers?: { [name: string]: string }): boolean {\n    try {\n      const content = fs.readFileSync(absoluteFilePath);\n      response.statusCode = 200;\n      const contentType = extensionToMime[path.extname(absoluteFilePath).substring(1)] || 'application/octet-stream';\n      response.setHeader('Content-Type', contentType);\n      response.setHeader('Content-Length', content.byteLength);\n      for (const [name, value] of Object.entries(headers || {}))\n        response.setHeader(name, value);\n      response.end(content);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  private _onRequest(request: http.IncomingMessage, response: http.ServerResponse) {\n    request.on('error', () => response.end());\n    try {\n      if (!request.url) {\n        response.end();\n        return;\n      }\n      const url = new URL('http://localhost' + request.url);\n      for (const route of this._routes) {\n        if (route.exact && url.pathname === route.exact && route.handler(request, response))\n          return;\n        if (route.prefix && url.pathname.startsWith(route.prefix) && route.handler(request, response))\n          return;\n      }\n      response.statusCode = 404;\n      response.end();\n    } catch (e) {\n      response.end();\n    }\n  }\n}\n\nconst extensionToMime: { [key: string]: string } = {\n  'css': 'text/css',\n  'html': 'text/html',\n  'jpeg': 'image/jpeg',\n  'jpg': 'image/jpeg',\n  'js': 'application/javascript',\n  'png': 'image/png',\n  'ttf': 'font/ttf',\n  'svg': 'image/svg+xml',\n  'webp': 'image/webp',\n  'woff': 'font/woff',\n  'woff2': 'font/woff2',\n};\n"],"file":"httpServer.js"}