{"version":3,"sources":["../../src/protocol/transport.ts"],"names":["Transport","constructor","pipeWrite","pipeRead","closeable","endian","_pipeWrite","_data","Buffer","from","_waitForNextTask","_closed","_bytesLeft","onmessage","onclose","_endian","_closeableStream","on","buffer","_dispatch","undefined","send","message","Error","data","dataLength","alloc","writeUInt32BE","length","writeUInt32LE","write","close","concat","readUInt32BE","readUInt32LE","slice","toString"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { makeWaitForNextTask } from '../utils/utils';\n\nexport interface WritableStream {\n  write(data: Buffer): void;\n}\n\nexport interface ReadableStream {\n  on(event: 'data', callback: (b: Buffer) => void): void;\n  on(event: 'close', callback: () => void): void;\n}\n\nexport interface ClosableStream {\n  close(): void;\n}\n\nexport class Transport {\n  private _pipeWrite: WritableStream;\n  private _data = Buffer.from([]);\n  private _waitForNextTask = makeWaitForNextTask();\n  private _closed = false;\n  private _bytesLeft = 0;\n\n  onmessage?: (message: string) => void;\n  onclose?: () => void;\n\n  private _endian: 'be' | 'le';\n  private _closeableStream: ClosableStream | undefined;\n\n  constructor(pipeWrite: WritableStream, pipeRead: ReadableStream, closeable?: ClosableStream, endian: 'be' | 'le' = 'le') {\n    this._pipeWrite = pipeWrite;\n    this._endian = endian;\n    this._closeableStream = closeable;\n    pipeRead.on('data', buffer => this._dispatch(buffer));\n    pipeRead.on('close', () => {\n      this._closed = true;\n      if (this.onclose)\n        this.onclose();\n    });\n    this.onmessage = undefined;\n    this.onclose = undefined;\n  }\n\n  send(message: string) {\n    if (this._closed)\n      throw new Error('Pipe has been closed');\n    const data = Buffer.from(message, 'utf-8');\n    const dataLength = Buffer.alloc(4);\n    if (this._endian === 'be')\n      dataLength.writeUInt32BE(data.length, 0);\n    else\n      dataLength.writeUInt32LE(data.length, 0);\n    this._pipeWrite.write(dataLength);\n    this._pipeWrite.write(data);\n  }\n\n  close() {\n    // Let it throw.\n    this._closeableStream!.close();\n  }\n\n  _dispatch(buffer: Buffer) {\n    this._data = Buffer.concat([this._data, buffer]);\n    while (true) {\n      if (!this._bytesLeft && this._data.length < 4) {\n        // Need more data.\n        break;\n      }\n\n      if (!this._bytesLeft) {\n        this._bytesLeft = this._endian === 'be' ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);\n        this._data = this._data.slice(4);\n      }\n\n      if (!this._bytesLeft || this._data.length < this._bytesLeft) {\n        // Need more data.\n        break;\n      }\n\n      const message = this._data.slice(0, this._bytesLeft);\n      this._data = this._data.slice(this._bytesLeft);\n      this._bytesLeft = 0;\n      this._waitForNextTask(() => {\n        if (this.onmessage)\n          this.onmessage(message.toString('utf-8'));\n      });\n    }\n  }\n}\n"],"file":"transport.js"}