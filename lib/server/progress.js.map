{"version":3,"sources":["../../src/server/progress.ts"],"names":["ProgressController","constructor","metadata","sdkObject","_forceAbort","_forceAbortPromise","_cleanups","_logName","_state","_deadline","_timeout","instrumentation","Promise","resolve","reject","catch","e","setLogName","logName","run","task","timeout","progress","log","message","push","onCallLog","timeUntilDeadline","isRunning","cleanupWhenAborted","cleanup","runCleanup","throwIfAborted","AbortedError","beforeInputAction","element","onBeforeInputAction","timeoutError","TimeoutError","timer","setTimeout","promise","result","race","all","splice","map","clearTimeout","Error"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TimeoutError } from '../utils/errors';\nimport { assert, monotonicTime } from '../utils/utils';\nimport { LogName } from '../utils/debugLogger';\nimport { CallMetadata, Instrumentation, SdkObject } from './instrumentation';\nimport { ElementHandle } from './dom';\n\nexport interface Progress {\n  log(message: string): void;\n  timeUntilDeadline(): number;\n  isRunning(): boolean;\n  cleanupWhenAborted(cleanup: () => any): void;\n  throwIfAborted(): void;\n  beforeInputAction(element: ElementHandle): Promise<void>;\n  metadata: CallMetadata;\n}\n\nexport class ProgressController {\n  // Promise and callback that forcefully abort the progress.\n  // This promise always rejects.\n  private _forceAbort: (error: Error) => void = () => {};\n  private _forceAbortPromise: Promise<any>;\n\n  // Cleanups to be run only in the case of abort.\n  private _cleanups: (() => any)[] = [];\n\n  private _logName = 'api';\n  private _state: 'before' | 'running' | 'aborted' | 'finished' = 'before';\n  private _deadline: number = 0;\n  private _timeout: number = 0;\n  readonly metadata: CallMetadata;\n  readonly instrumentation: Instrumentation;\n  readonly sdkObject: SdkObject;\n\n  constructor(metadata: CallMetadata, sdkObject: SdkObject) {\n    this.metadata = metadata;\n    this.sdkObject = sdkObject;\n    this.instrumentation = sdkObject.instrumentation;\n    this._forceAbortPromise = new Promise((resolve, reject) => this._forceAbort = reject);\n    this._forceAbortPromise.catch(e => null);  // Prevent unhandled promise rejection.\n  }\n\n  setLogName(logName: LogName) {\n    this._logName = logName;\n  }\n\n  async run<T>(task: (progress: Progress) => Promise<T>, timeout?: number): Promise<T> {\n    if (timeout) {\n      this._timeout = timeout;\n      this._deadline = timeout ? monotonicTime() + timeout : 0;\n    }\n\n    assert(this._state === 'before');\n    this._state = 'running';\n\n    const progress: Progress = {\n      log: message => {\n        if (this._state === 'running')\n          this.metadata.log.push(message);\n        // Note: we might be sending logs after progress has finished, for example browser logs.\n        this.instrumentation.onCallLog(this._logName, message, this.sdkObject, this.metadata);\n      },\n      timeUntilDeadline: () => this._deadline ? this._deadline - monotonicTime() : 2147483647, // 2^31-1 safe setTimeout in Node.\n      isRunning: () => this._state === 'running',\n      cleanupWhenAborted: (cleanup: () => any) => {\n        if (this._state === 'running')\n          this._cleanups.push(cleanup);\n        else\n          runCleanup(cleanup);\n      },\n      throwIfAborted: () => {\n        if (this._state === 'aborted')\n          throw new AbortedError();\n      },\n      beforeInputAction: async (element: ElementHandle) => {\n        await this.instrumentation.onBeforeInputAction(this.sdkObject, this.metadata, element);\n      },\n      metadata: this.metadata\n    };\n\n    const timeoutError = new TimeoutError(`Timeout ${this._timeout}ms exceeded.`);\n    const timer = setTimeout(() => this._forceAbort(timeoutError), progress.timeUntilDeadline());\n    try {\n      const promise = task(progress);\n      const result = await Promise.race([promise, this._forceAbortPromise]);\n      this._state = 'finished';\n      return result;\n    } catch (e) {\n      this._state = 'aborted';\n      await Promise.all(this._cleanups.splice(0).map(runCleanup));\n      throw e;\n    } finally {\n      clearTimeout(timer);\n    }\n  }\n}\n\nasync function runCleanup(cleanup: () => any) {\n  try {\n    await cleanup();\n  } catch (e) {\n  }\n}\n\nclass AbortedError extends Error {}\n"],"file":"progress.js"}