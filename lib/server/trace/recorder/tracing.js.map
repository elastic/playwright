{"version":3,"sources":["../../../../src/server/trace/recorder/tracing.ts"],"names":["VERSION","kScreencastOptions","width","height","quality","Tracing","constructor","context","_writeChain","Promise","resolve","_snapshotter","_screencastListeners","_pendingCalls","Map","_context","_resourcesDir","_recording","_isStopping","_tracesDir","_allResources","Set","_browser","options","tracesDir","path","join","Snapshotter","start","Error","state","traceFile","name","lastReset","sha1s","event","version","type","browserName","_options","_appendTraceEvent","screenshots","_startScreencast","_stopScreencast","fs","promises","mkdir","recursive","instrumentation","addListener","_appendTraceOperation","snapshots","reset","stop","markerEvent","resetIndex","appendFile","JSON","stringify","page","pages","_startScreencastInPage","push","eventsHelper","addEventListener","BrowserContext","Events","Page","bind","removeEventListeners","setScreencastOptions","removeListener","undefined","dispose","export","sdkObject","metadata","beforeSnapshot","actionSnapshot","afterSnapshot","values","all","callMetadata","error","message","onAfterCall","recording","_filterTrace","zipFile","yazl","ZipFile","failedPromise","_","reject","on","succeededPromise","fulfill","addFile","zipFileName","sha1","end","f","outputStream","pipe","createWriteStream","artifact","Artifact","reportFinished","race","finally","unlink","catch","sinceResetIndex","ext","extname","traceFileCopy","substring","length","fileStream","createReadStream","rl","readline","createInterface","input","crlfDelay","Infinity","copyChain","foundMarker","line","parse","visitSha1s","then","e","close","_captureSnapshot","element","attribution","started","shouldCaptureSnapshot","snapshotName","id","title","captureSnapshot","onBeforeCall","set","onBeforeInputAction","get","pendingCall","delete","hasSnapshot","onEvent","onBlob","blob","_appendResource","buffer","onResourceSnapshot","snapshot","onFrameSnapshot","prefix","guid","frameSeq","ScreencastFrame","params","suffix","String","padStart","pageId","timestamp","has","add","resourcePath","access","writeFile","cb","result","object","Array","isArray","forEach","o","key","endsWith","commandsWithTracingSnapshots","method"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport yazl from 'yazl';\nimport readline from 'readline';\nimport { EventEmitter } from 'events';\nimport { createGuid, mkdirIfNeeded, monotonicTime } from '../../../utils/utils';\nimport { Artifact } from '../../artifact';\nimport { BrowserContext } from '../../browserContext';\nimport { ElementHandle } from '../../dom';\nimport { eventsHelper, RegisteredListener } from '../../../utils/eventsHelper';\nimport { CallMetadata, InstrumentationListener, SdkObject } from '../../instrumentation';\nimport { Page } from '../../page';\nimport * as trace from '../common/traceEvents';\nimport { commandsWithTracingSnapshots } from '../../../protocol/channels';\nimport { Snapshotter, SnapshotterBlob, SnapshotterDelegate } from '../../snapshot/snapshotter';\nimport { FrameSnapshot, ResourceSnapshot } from '../../snapshot/snapshotTypes';\n\nexport type TracerOptions = {\n  name?: string;\n  snapshots?: boolean;\n  screenshots?: boolean;\n};\n\nexport const VERSION = 2;\n\ntype RecordingState = {\n  options: TracerOptions,\n  traceFile: string,\n  lastReset: number,\n  sha1s: Set<string>,\n};\n\nconst kScreencastOptions = { width: 800, height: 600, quality: 90 };\n\nexport class Tracing implements InstrumentationListener, SnapshotterDelegate {\n  private _writeChain = Promise.resolve();\n  private _snapshotter: Snapshotter;\n  private _screencastListeners: RegisteredListener[] = [];\n  private _pendingCalls = new Map<string, { sdkObject: SdkObject, metadata: CallMetadata, beforeSnapshot: Promise<void>, actionSnapshot?: Promise<void>, afterSnapshot?: Promise<void> }>();\n  private _context: BrowserContext;\n  private _resourcesDir: string;\n  private _recording: RecordingState | undefined;\n  private _isStopping = false;\n  private _tracesDir: string;\n  private _allResources = new Set<string>();\n\n  constructor(context: BrowserContext) {\n    this._context = context;\n    this._tracesDir = context._browser.options.tracesDir;\n    this._resourcesDir = path.join(this._tracesDir, 'resources');\n    this._snapshotter = new Snapshotter(context, this);\n  }\n\n  async start(options: TracerOptions): Promise<void> {\n    if (this._isStopping)\n      throw new Error('Cannot start tracing while stopping');\n    // context + page must be the first events added, this method can't have awaits before them.\n\n    const state = this._recording;\n    if (!state) {\n      // TODO: passing the same name for two contexts makes them write into a single file\n      // and conflict.\n      const traceFile = path.join(this._tracesDir, (options.name || createGuid()) + '.trace');\n      this._recording = { options, traceFile, lastReset: 0, sha1s: new Set() };\n      this._writeChain = mkdirIfNeeded(traceFile);\n      const event: trace.ContextCreatedTraceEvent = {\n        version: VERSION,\n        type: 'context-options',\n        browserName: this._context._browser.options.name,\n        options: this._context._options\n      };\n      this._appendTraceEvent(event);\n    }\n\n    if (!state?.options?.screenshots && options.screenshots)\n      this._startScreencast();\n    else if (state?.options?.screenshots && !options.screenshots)\n      this._stopScreencast();\n\n    // context + page must be the first events added, no awaits above this line.\n    await fs.promises.mkdir(this._resourcesDir, { recursive: true });\n\n    if (!state)\n      this._context.instrumentation.addListener(this);\n\n    await this._appendTraceOperation(async () => {\n      if (options.snapshots && state?.options?.snapshots) {\n        // Reset snapshots to avoid back-references.\n        await this._snapshotter.reset();\n      } else if (options.snapshots) {\n        await this._snapshotter.start();\n      } else if (state?.options?.snapshots) {\n        await this._snapshotter.stop();\n      }\n\n      if (state) {\n        state.lastReset++;\n        const markerEvent: trace.MarkerTraceEvent = { type: 'marker', resetIndex: state.lastReset };\n        await fs.promises.appendFile(state.traceFile, JSON.stringify(markerEvent) + '\\n');\n      }\n    });\n\n    if (this._recording)\n      this._recording.options = options;\n  }\n\n  private _startScreencast() {\n    for (const page of this._context.pages())\n      this._startScreencastInPage(page);\n    this._screencastListeners.push(\n        eventsHelper.addEventListener(this._context, BrowserContext.Events.Page, this._startScreencastInPage.bind(this)),\n    );\n  }\n\n  private _stopScreencast() {\n    eventsHelper.removeEventListeners(this._screencastListeners);\n    for (const page of this._context.pages())\n      page.setScreencastOptions(null);\n  }\n\n  async stop(): Promise<void> {\n    if (!this._recording || this._isStopping)\n      return;\n    this._isStopping = true;\n    this._context.instrumentation.removeListener(this);\n    this._stopScreencast();\n    await this._snapshotter.stop();\n    // Ensure all writes are finished.\n    await this._writeChain;\n    this._recording = undefined;\n    this._isStopping = false;\n  }\n\n  async dispose() {\n    this._snapshotter.dispose();\n    await this._writeChain;\n  }\n\n  async export(): Promise<Artifact> {\n    for (const { sdkObject, metadata, beforeSnapshot, actionSnapshot, afterSnapshot } of this._pendingCalls.values()) {\n      await Promise.all([beforeSnapshot, actionSnapshot, afterSnapshot]);\n      let callMetadata = metadata;\n      if (!afterSnapshot) {\n        // Note: we should not modify metadata here to avoid side-effects in any other place.\n        callMetadata = {\n          ...metadata,\n          error: { error: { name: 'Error', message: 'Action was interrupted' } },\n        };\n      }\n      await this.onAfterCall(sdkObject, callMetadata);\n    }\n\n    if (!this._recording)\n      throw new Error('Must start tracing before exporting');\n\n    // Chain the export operation against write operations,\n    // so that neither trace file nor sha1s change during the export.\n    return await this._appendTraceOperation(async () => {\n      const recording = this._recording!;\n      let state = recording;\n      // Make a filtered trace if needed.\n      if (recording.lastReset)\n        state = await this._filterTrace(recording, recording.lastReset);\n\n      const zipFile = new yazl.ZipFile();\n      const failedPromise = new Promise<Artifact>((_, reject) => (zipFile as any as EventEmitter).on('error', reject));\n      const succeededPromise = new Promise<Artifact>(async fulfill => {\n        zipFile.addFile(state.traceFile, 'trace.trace');\n        const zipFileName = state.traceFile + '.zip';\n        for (const sha1 of state.sha1s)\n          zipFile.addFile(path.join(this._resourcesDir, sha1), path.join('resources', sha1));\n        zipFile.end();\n        await new Promise(f => {\n          zipFile.outputStream.pipe(fs.createWriteStream(zipFileName)).on('close', f);\n        });\n        const artifact = new Artifact(this._context, zipFileName);\n        artifact.reportFinished();\n        fulfill(artifact);\n      });\n      return Promise.race([failedPromise, succeededPromise]).finally(async () => {\n        // Remove the filtered trace.\n        if (recording.lastReset)\n          await fs.promises.unlink(state.traceFile).catch(() => {});\n      });\n    });\n  }\n\n  private async _filterTrace(state: RecordingState, sinceResetIndex: number): Promise<RecordingState> {\n    const ext = path.extname(state.traceFile);\n    const traceFileCopy = state.traceFile.substring(0, state.traceFile.length - ext.length) + '-copy' + sinceResetIndex + ext;\n    const sha1s = new Set<string>();\n    await new Promise<void>((resolve, reject) => {\n      const fileStream = fs.createReadStream(state.traceFile, 'utf8');\n      const rl = readline.createInterface({\n        input: fileStream,\n        crlfDelay: Infinity\n      });\n      let copyChain = Promise.resolve();\n      let foundMarker = false;\n      rl.on('line', line => {\n        try {\n          const event = JSON.parse(line) as trace.TraceEvent;\n          if (event.type === 'marker') {\n            if (event.resetIndex === sinceResetIndex)\n              foundMarker = true;\n          } else if ((event.type === 'resource-snapshot' && state.options.snapshots) || event.type === 'context-options' || foundMarker) {\n            // We keep:\n            // - old resource events for snapshots;\n            // - initial context options event;\n            // - all events after the marker that are not markers.\n            visitSha1s(event, sha1s);\n            copyChain = copyChain.then(() => fs.promises.appendFile(traceFileCopy, line + '\\n'));\n          }\n        } catch (e) {\n          reject(e);\n          fileStream.close();\n          rl.close();\n        }\n      });\n      rl.on('error', reject);\n      rl.on('close', async () => {\n        await copyChain;\n        resolve();\n      });\n    });\n    return { options: state.options, lastReset: state.lastReset, sha1s, traceFile: traceFileCopy };\n  }\n\n  async _captureSnapshot(name: 'before' | 'after' | 'action' | 'event', sdkObject: SdkObject, metadata: CallMetadata, element?: ElementHandle) {\n    if (!sdkObject.attribution.page)\n      return;\n    if (!this._snapshotter.started())\n      return;\n    if (!shouldCaptureSnapshot(metadata))\n      return;\n    const snapshotName = `${name}@${metadata.id}`;\n    metadata.snapshots.push({ title: name, snapshotName });\n    await this._snapshotter.captureSnapshot(sdkObject.attribution.page, snapshotName, element).catch(() => {});\n  }\n\n  async onBeforeCall(sdkObject: SdkObject, metadata: CallMetadata) {\n    const beforeSnapshot = this._captureSnapshot('before', sdkObject, metadata);\n    this._pendingCalls.set(metadata.id, { sdkObject, metadata, beforeSnapshot });\n    await beforeSnapshot;\n  }\n\n  async onBeforeInputAction(sdkObject: SdkObject, metadata: CallMetadata, element: ElementHandle) {\n    const actionSnapshot = this._captureSnapshot('action', sdkObject, metadata, element);\n    this._pendingCalls.get(metadata.id)!.actionSnapshot = actionSnapshot;\n    await actionSnapshot;\n  }\n\n  async onAfterCall(sdkObject: SdkObject, metadata: CallMetadata) {\n    const pendingCall = this._pendingCalls.get(metadata.id);\n    if (!pendingCall || pendingCall.afterSnapshot)\n      return;\n    if (!sdkObject.attribution.page) {\n      this._pendingCalls.delete(metadata.id);\n      return;\n    }\n    pendingCall.afterSnapshot = this._captureSnapshot('after', sdkObject, metadata);\n    await pendingCall.afterSnapshot;\n    const event: trace.ActionTraceEvent = { type: 'action', metadata, hasSnapshot: shouldCaptureSnapshot(metadata) };\n    this._appendTraceEvent(event);\n    this._pendingCalls.delete(metadata.id);\n  }\n\n  onEvent(sdkObject: SdkObject, metadata: CallMetadata) {\n    if (!sdkObject.attribution.page)\n      return;\n    const event: trace.ActionTraceEvent = { type: 'event', metadata, hasSnapshot: false };\n    this._appendTraceEvent(event);\n  }\n\n  onBlob(blob: SnapshotterBlob): void {\n    this._appendResource(blob.sha1, blob.buffer);\n  }\n\n  onResourceSnapshot(snapshot: ResourceSnapshot): void {\n    this._appendTraceEvent({ type: 'resource-snapshot', snapshot });\n  }\n\n  onFrameSnapshot(snapshot: FrameSnapshot): void {\n    this._appendTraceEvent({ type: 'frame-snapshot', snapshot });\n  }\n\n  private _startScreencastInPage(page: Page) {\n    page.setScreencastOptions(kScreencastOptions);\n    const prefix = page.guid;\n    let frameSeq = 0;\n    this._screencastListeners.push(\n        eventsHelper.addEventListener(page, Page.Events.ScreencastFrame, params => {\n          const suffix = String(++frameSeq).padStart(10, '0');\n          const sha1 = `${prefix}-${suffix}.jpeg`;\n          const event: trace.ScreencastFrameTraceEvent = {\n            type: 'screencast-frame',\n            pageId: page.guid,\n            sha1,\n            width: params.width,\n            height: params.height,\n            timestamp: monotonicTime()\n          };\n          // Make sure to write the screencast frame before adding a reference to it.\n          this._appendResource(sha1, params.buffer);\n          this._appendTraceEvent(event);\n        }),\n    );\n  }\n\n  private _appendTraceEvent(event: trace.TraceEvent) {\n    // Serialize all writes to the trace file.\n    this._appendTraceOperation(async () => {\n      visitSha1s(event, this._recording!.sha1s);\n      await fs.promises.appendFile(this._recording!.traceFile, JSON.stringify(event) + '\\n');\n    });\n  }\n\n  private _appendResource(sha1: string, buffer: Buffer) {\n    if (this._allResources.has(sha1))\n      return;\n    this._allResources.add(sha1);\n    this._appendTraceOperation(async () => {\n      const resourcePath = path.join(this._resourcesDir, sha1);\n      try {\n        // Perhaps we've already written this resource?\n        await fs.promises.access(resourcePath);\n      } catch (e) {\n        // If not, let's write! Note that async access is safe because we\n        // never remove resources until the very end.\n        await fs.promises.writeFile(resourcePath, buffer).catch(() => {});\n      }\n    });\n  }\n\n  private async _appendTraceOperation<T>(cb: () => Promise<T>): Promise<T> {\n    let error: Error | undefined;\n    let result: T | undefined;\n    this._writeChain = this._writeChain.then(async () => {\n      try {\n        result = await cb();\n      } catch (e) {\n        error = e;\n      }\n    });\n    await this._writeChain;\n    if (error)\n      throw error;\n    return result!;\n  }\n}\n\nfunction visitSha1s(object: any, sha1s: Set<string>) {\n  if (Array.isArray(object)) {\n    object.forEach(o => visitSha1s(o, sha1s));\n    return;\n  }\n  if (typeof object === 'object') {\n    for (const key in object) {\n      if (key === 'sha1' || key.endsWith('Sha1')) {\n        const sha1 = object[key];\n        if (sha1)\n          sha1s.add(sha1);\n      }\n      visitSha1s(object[key], sha1s);\n    }\n    return;\n  }\n}\n\nexport function shouldCaptureSnapshot(metadata: CallMetadata): boolean {\n  return commandsWithTracingSnapshots.has(metadata.type + '.' + metadata.method);\n}\n"],"file":"tracing.js"}