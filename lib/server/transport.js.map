{"version":3,"sources":["../../src/server/transport.ts"],"names":["WebSocketTransport","connect","progress","url","headers","log","transport","success","cleanupWhenAborted","closeAndWait","catch","e","Promise","fulfill","reject","_ws","addEventListener","event","message","Error","close","constructor","_progress","onmessage","onclose","wsEndpoint","WebSocket","perMessageDeflate","maxPayload","handshakeTimeout","timeUntilDeadline","messageWrap","call","JSON","parse","data","send","stringify","promise","f","once"],"mappings":"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","sourcesContent":["/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport WebSocket from 'ws';\nimport { Progress } from './progress';\nimport { makeWaitForNextTask } from '../utils/utils';\n\nexport type ProtocolRequest = {\n  id: number;\n  method: string;\n  params: any;\n  sessionId?: string;\n};\n\nexport type ProtocolResponse = {\n  id?: number;\n  method?: string;\n  sessionId?: string;\n  error?: { message: string; data: any; };\n  params?: any;\n  result?: any;\n  pageProxyId?: string;\n  browserContextId?: string;\n};\n\nexport interface ConnectionTransport {\n  send(s: ProtocolRequest): void;\n  close(): void;  // Note: calling close is expected to issue onclose at some point.\n  onmessage?: (message: ProtocolResponse) => void,\n  onclose?: () => void,\n}\n\nexport class WebSocketTransport implements ConnectionTransport {\n  private _ws: WebSocket;\n  private _progress: Progress;\n\n  onmessage?: (message: ProtocolResponse) => void;\n  onclose?: () => void;\n  readonly wsEndpoint: string;\n\n  static async connect(progress: Progress, url: string, headers?: { [key: string]: string; }): Promise<WebSocketTransport> {\n    progress.log(`<ws connecting> ${url}`);\n    const transport = new WebSocketTransport(progress, url, headers);\n    let success = false;\n    progress.cleanupWhenAborted(async () => {\n      if (!success)\n        await transport.closeAndWait().catch(e => null);\n    });\n    await new Promise<WebSocketTransport>((fulfill, reject) => {\n      transport._ws.addEventListener('open', async () => {\n        progress.log(`<ws connected> ${url}`);\n        fulfill(transport);\n      });\n      transport._ws.addEventListener('error', event => {\n        progress.log(`<ws connect error> ${url} ${event.message}`);\n        reject(new Error('WebSocket error: ' + event.message));\n        transport._ws.close();\n      });\n    });\n    success = true;\n    return transport;\n  }\n\n  constructor(progress: Progress, url: string, headers?: { [key: string]: string; }) {\n    this.wsEndpoint = url;\n    this._ws = new WebSocket(url, [], {\n      perMessageDeflate: false,\n      maxPayload: 256 * 1024 * 1024, // 256Mb,\n      handshakeTimeout: progress.timeUntilDeadline(),\n      headers\n    });\n    this._progress = progress;\n    // The 'ws' module in node sometimes sends us multiple messages in a single task.\n    // In Web, all IO callbacks (e.g. WebSocket callbacks)\n    // are dispatched into separate tasks, so there's no need\n    // to do anything extra.\n    const messageWrap: (cb: () => void) => void = makeWaitForNextTask();\n\n    this._ws.addEventListener('message', event => {\n      messageWrap(() => {\n        try {\n          if (this.onmessage)\n            this.onmessage.call(null, JSON.parse(event.data));\n        } catch (e) {\n          this._ws.close();\n        }\n      });\n    });\n\n    this._ws.addEventListener('close', event => {\n      this._progress && this._progress.log(`<ws disconnected> ${url}`);\n      if (this.onclose)\n        this.onclose.call(null);\n    });\n    // Prevent Error: read ECONNRESET.\n    this._ws.addEventListener('error', () => {});\n  }\n\n  send(message: ProtocolRequest) {\n    this._ws.send(JSON.stringify(message));\n  }\n\n  close() {\n    this._progress && this._progress.log(`<ws disconnecting> ${this._ws.url}`);\n    this._ws.close();\n  }\n\n  async closeAndWait() {\n    const promise = new Promise(f => this._ws.once('close', f));\n    this.close();\n    await promise; // Make sure to await the actual disconnect.\n  }\n}\n"],"file":"transport.js"}