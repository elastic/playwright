{"version":3,"sources":["../../src/client/elementHandle.ts"],"names":["ElementHandle","JSHandle","from","handle","_object","fromNullable","constructor","parent","type","guid","initializer","_elementChannel","_channel","asElement","ownerFrame","_wrapApiCall","channel","Frame","frame","contentFrame","getAttribute","name","value","undefined","inputValue","textContent","innerText","innerHTML","isChecked","isDisabled","isEditable","isEnabled","isHidden","isVisible","dispatchEvent","eventInit","scrollIntoViewIfNeeded","options","hover","click","dblclick","tap","selectOption","values","result","convertSelectOptionValues","fill","selectText","setInputFiles","files","convertInputFiles","focus","text","press","key","check","uncheck","boundingBox","screenshot","copy","determineScreenshotType","buffer","Buffer","binary","path","fs","promises","writeFile","$","selector","querySelector","element","$$","querySelectorAll","elements","map","h","$eval","pageFunction","arg","evalOnSelector","expression","String","isFunction","$$eval","evalOnSelectorAll","waitForElementState","state","waitForSelector","Array","isArray","length","i","v","items","filePayloads","Promise","all","item","basename","readFile","toString","mimeType","mime","getType","Error"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as channels from '../protocol/channels';\nimport { Frame } from './frame';\nimport { JSHandle, serializeArgument, parseResult } from './jsHandle';\nimport { ChannelOwner } from './channelOwner';\nimport { SelectOption, FilePayload, Rect, SelectOptionOptions } from './types';\nimport fs from 'fs';\nimport * as mime from 'mime';\nimport path from 'path';\nimport { assert, isString, mkdirIfNeeded } from '../utils/utils';\nimport * as api from '../../types/types';\nimport * as structs from '../../types/structs';\n\nexport class ElementHandle<T extends Node = Node> extends JSHandle<T> implements api.ElementHandle {\n  readonly _elementChannel: channels.ElementHandleChannel;\n\n  static from(handle: channels.ElementHandleChannel): ElementHandle {\n    return (handle as any)._object;\n  }\n\n  static fromNullable(handle: channels.ElementHandleChannel | undefined): ElementHandle | null {\n    return handle ? ElementHandle.from(handle) : null;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.JSHandleInitializer) {\n    super(parent, type, guid, initializer);\n    this._elementChannel = this._channel as channels.ElementHandleChannel;\n  }\n\n  asElement(): T extends Node ? ElementHandle<T> : null {\n    return this as any;\n  }\n\n  async ownerFrame(): Promise<Frame | null> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return Frame.fromNullable((await channel.ownerFrame()).frame);\n    });\n  }\n\n  async contentFrame(): Promise<Frame | null> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return Frame.fromNullable((await channel.contentFrame()).frame);\n    });\n  }\n\n  async getAttribute(name: string): Promise<string | null> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      const value = (await channel.getAttribute({ name })).value;\n      return value === undefined ? null : value;\n    });\n  }\n\n  async inputValue(): Promise<string> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return (await channel.inputValue()).value;\n    });\n  }\n\n  async textContent(): Promise<string | null> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      const value = (await channel.textContent()).value;\n      return value === undefined ? null : value;\n    });\n  }\n\n  async innerText(): Promise<string> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return (await channel.innerText()).value;\n    });\n  }\n\n  async innerHTML(): Promise<string> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return (await channel.innerHTML()).value;\n    });\n  }\n\n  async isChecked(): Promise<boolean> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return (await channel.isChecked()).value;\n    });\n  }\n\n  async isDisabled(): Promise<boolean> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return (await channel.isDisabled()).value;\n    });\n  }\n\n  async isEditable(): Promise<boolean> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return (await channel.isEditable()).value;\n    });\n  }\n\n  async isEnabled(): Promise<boolean> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return (await channel.isEnabled()).value;\n    });\n  }\n\n  async isHidden(): Promise<boolean> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return (await channel.isHidden()).value;\n    });\n  }\n\n  async isVisible(): Promise<boolean> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return (await channel.isVisible()).value;\n    });\n  }\n\n  async dispatchEvent(type: string, eventInit: Object = {}) {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      await channel.dispatchEvent({ type, eventInit: serializeArgument(eventInit) });\n    });\n  }\n\n  async scrollIntoViewIfNeeded(options: channels.ElementHandleScrollIntoViewIfNeededOptions = {}) {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      await channel.scrollIntoViewIfNeeded(options);\n    });\n  }\n\n  async hover(options: channels.ElementHandleHoverOptions = {}): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      await channel.hover(options);\n    });\n  }\n\n  async click(options: channels.ElementHandleClickOptions = {}): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return await channel.click(options);\n    });\n  }\n\n  async dblclick(options: channels.ElementHandleDblclickOptions = {}): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return await channel.dblclick(options);\n    });\n  }\n\n  async tap(options: channels.ElementHandleTapOptions = {}): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return await channel.tap(options);\n    });\n  }\n\n  async selectOption(values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null, options: SelectOptionOptions = {}): Promise<string[]> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      const result = await channel.selectOption({ ...convertSelectOptionValues(values), ...options });\n      return result.values;\n    });\n  }\n\n  async fill(value: string, options: channels.ElementHandleFillOptions = {}): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return await channel.fill({ value, ...options });\n    });\n  }\n\n  async selectText(options: channels.ElementHandleSelectTextOptions = {}): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      await channel.selectText(options);\n    });\n  }\n\n  async setInputFiles(files: string | FilePayload | string[] | FilePayload[], options: channels.ElementHandleSetInputFilesOptions = {}) {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      await channel.setInputFiles({ files: await convertInputFiles(files), ...options });\n    });\n  }\n\n  async focus(): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      await channel.focus();\n    });\n  }\n\n  async type(text: string, options: channels.ElementHandleTypeOptions = {}): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      await channel.type({ text, ...options });\n    });\n  }\n\n  async press(key: string, options: channels.ElementHandlePressOptions = {}): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      await channel.press({ key, ...options });\n    });\n  }\n\n  async check(options: channels.ElementHandleCheckOptions = {}) {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return await channel.check(options);\n    });\n  }\n\n  async uncheck(options: channels.ElementHandleUncheckOptions = {}) {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return await channel.uncheck(options);\n    });\n  }\n\n  async boundingBox(): Promise<Rect | null> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      const value = (await channel.boundingBox()).value;\n      return value === undefined ? null : value;\n    });\n  }\n\n  async screenshot(options: channels.ElementHandleScreenshotOptions & { path?: string } = {}): Promise<Buffer> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      const copy = { ...options };\n      if (!copy.type)\n        copy.type = determineScreenshotType(options);\n      const result = await channel.screenshot(copy);\n      const buffer = Buffer.from(result.binary, 'base64');\n      if (options.path) {\n        await mkdirIfNeeded(options.path);\n        await fs.promises.writeFile(options.path, buffer);\n      }\n      return buffer;\n    });\n  }\n\n  async $(selector: string): Promise<ElementHandle<SVGElement | HTMLElement> | null> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return ElementHandle.fromNullable((await channel.querySelector({ selector })).element) as ElementHandle<SVGElement | HTMLElement> | null;\n    });\n  }\n\n  async $$(selector: string): Promise<ElementHandle<SVGElement | HTMLElement>[]> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      const result = await channel.querySelectorAll({ selector });\n      return result.elements.map(h => ElementHandle.from(h) as ElementHandle<SVGElement | HTMLElement>);\n    });\n  }\n\n  async $eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element, Arg, R>, arg?: Arg): Promise<R> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      const result = await channel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n      return parseResult(result.value);\n    });\n  }\n\n  async $$eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element[], Arg, R>, arg?: Arg): Promise<R> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      const result = await channel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n      return parseResult(result.value);\n    });\n  }\n\n  async waitForElementState(state: 'visible' | 'hidden' | 'stable' | 'enabled' | 'disabled', options: channels.ElementHandleWaitForElementStateOptions = {}): Promise<void> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      return await channel.waitForElementState({ state, ...options });\n    });\n  }\n\n  waitForSelector(selector: string, options: channels.ElementHandleWaitForSelectorOptions & { state: 'attached' | 'visible' }): Promise<ElementHandle<SVGElement | HTMLElement>>;\n  waitForSelector(selector: string, options?: channels.ElementHandleWaitForSelectorOptions): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n  async waitForSelector(selector: string, options: channels.ElementHandleWaitForSelectorOptions = {}): Promise<ElementHandle<SVGElement | HTMLElement> | null> {\n    return this._wrapApiCall(async (channel: channels.ElementHandleChannel) => {\n      const result = await channel.waitForSelector({ selector, ...options });\n      return ElementHandle.fromNullable(result.element) as ElementHandle<SVGElement | HTMLElement> | null;\n    });\n  }\n}\n\nexport function convertSelectOptionValues(values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null): { elements?: channels.ElementHandleChannel[], options?: SelectOption[] } {\n  if (values === null)\n    return {};\n  if (!Array.isArray(values))\n    values = [ values as any ];\n  if (!values.length)\n    return {};\n  for (let i = 0; i < values.length; i++)\n    assert(values[i] !== null, `options[${i}]: expected object, got null`);\n  if (values[0] instanceof ElementHandle)\n    return { elements: (values as ElementHandle[]).map((v: ElementHandle) => v._elementChannel) };\n  if (isString(values[0]))\n    return { options: (values as string[]).map(value => ({ value })) };\n  return { options: values as SelectOption[] };\n}\n\ntype SetInputFilesFiles = channels.ElementHandleSetInputFilesParams['files'];\nexport async function convertInputFiles(files: string | FilePayload | string[] | FilePayload[]): Promise<SetInputFilesFiles> {\n  const items: (string | FilePayload)[] = Array.isArray(files) ? files : [ files ];\n  const filePayloads: SetInputFilesFiles = await Promise.all(items.map(async item => {\n    if (typeof item === 'string') {\n      return {\n        name: path.basename(item),\n        buffer: (await fs.promises.readFile(item)).toString('base64')\n      };\n    } else {\n      return {\n        name: item.name,\n        mimeType: item.mimeType,\n        buffer: item.buffer.toString('base64'),\n      };\n    }\n  }));\n  return filePayloads;\n}\n\nexport function determineScreenshotType(options: { path?: string, type?: 'png' | 'jpeg' }): 'png' | 'jpeg' | undefined {\n  if (options.path) {\n    const mimeType = mime.getType(options.path);\n    if (mimeType === 'image/png')\n      return 'png';\n    else if (mimeType === 'image/jpeg')\n      return 'jpeg';\n    throw new Error(`path: unsupported mime type \"${mimeType}\"`);\n  }\n  return options.type;\n}\n"],"file":"elementHandle.js"}