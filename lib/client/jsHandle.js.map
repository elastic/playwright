{"version":3,"sources":["../../src/client/jsHandle.ts"],"names":["JSHandle","ChannelOwner","from","handle","_object","constructor","parent","type","guid","initializer","_preview","_initializer","preview","_channel","on","evaluate","pageFunction","arg","_wrapApiCall","channel","result","evaluateExpression","expression","String","isFunction","serializeArgument","parseResult","value","evaluateHandle","evaluateExpressionHandle","getProperty","propertyName","name","getProperties","map","Map","getPropertyList","properties","set","jsonValue","asElement","dispose","toString","handles","pushHandle","push","length","h","fallThrough","Set","undefined","assertMaxArguments","count","max","Error"],"mappings":";;;;;;;;;;AAiBA;;AACA;;AAlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQO,MAAMA,QAAN,SAAgCC,0BAAhC,CAA6H;AAGvH,SAAJC,IAAI,CAACC,MAAD,EAA6C;AACtD,WAAQA,MAAD,CAAgBC,OAAvB;AACD;;AAEDC,EAAAA,WAAW,CAACC,MAAD,EAAuBC,IAAvB,EAAqCC,IAArC,EAAmDC,WAAnD,EAA8F;AACvG,UAAMH,MAAN,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,WAA1B;AADuG,SANjGC,QAMiG;AAEvG,SAAKA,QAAL,GAAgB,KAAKC,YAAL,CAAkBC,OAAlC;;AACA,SAAKC,QAAL,CAAcC,EAAd,CAAiB,gBAAjB,EAAmC,CAAC;AAACF,MAAAA;AAAD,KAAD,KAAe,KAAKF,QAAL,GAAgBE,OAAlE;AACD;;AAEa,QAARG,QAAQ,CAASC,YAAT,EAA0DC,GAA1D,EAAiF;AAC7F,WAAO,KAAKC,YAAL,CAAkB,MAAOC,OAAP,IAA6C;AACpE,YAAMC,MAAM,GAAG,MAAMD,OAAO,CAACE,kBAAR,CAA2B;AAAEC,QAAAA,UAAU,EAAEC,MAAM,CAACP,YAAD,CAApB;AAAoCQ,QAAAA,UAAU,EAAE,OAAOR,YAAP,KAAwB,UAAxE;AAAoFC,QAAAA,GAAG,EAAEQ,iBAAiB,CAACR,GAAD;AAA1G,OAA3B,CAArB;AACA,aAAOS,WAAW,CAACN,MAAM,CAACO,KAAR,CAAlB;AACD,KAHM,CAAP;AAID;;AAEmB,QAAdC,cAAc,CAASZ,YAAT,EAA0DC,GAA1D,EAAsG;AACxH,WAAO,KAAKC,YAAL,CAAkB,MAAOC,OAAP,IAA6C;AACpE,YAAMC,MAAM,GAAG,MAAMD,OAAO,CAACU,wBAAR,CAAiC;AAAEP,QAAAA,UAAU,EAAEC,MAAM,CAACP,YAAD,CAApB;AAAoCQ,QAAAA,UAAU,EAAE,OAAOR,YAAP,KAAwB,UAAxE;AAAoFC,QAAAA,GAAG,EAAEQ,iBAAiB,CAACR,GAAD;AAA1G,OAAjC,CAArB;AACA,aAAOjB,QAAQ,CAACE,IAAT,CAAckB,MAAM,CAACjB,MAArB,CAAP;AACD,KAHM,CAAP;AAID;;AAEgB,QAAX2B,WAAW,CAACC,YAAD,EAA0C;AACzD,WAAO,KAAKb,YAAL,CAAkB,MAAOC,OAAP,IAA6C;AACpE,YAAMC,MAAM,GAAG,MAAMD,OAAO,CAACW,WAAR,CAAoB;AAAEE,QAAAA,IAAI,EAAED;AAAR,OAApB,CAArB;AACA,aAAO/B,QAAQ,CAACE,IAAT,CAAckB,MAAM,CAACjB,MAArB,CAAP;AACD,KAHM,CAAP;AAID;;AAEkB,QAAb8B,aAAa,GAAmC;AACpD,WAAO,KAAKf,YAAL,CAAkB,MAAOC,OAAP,IAA6C;AACpE,YAAMe,GAAG,GAAG,IAAIC,GAAJ,EAAZ;;AACA,WAAK,MAAM;AAAEH,QAAAA,IAAF;AAAQL,QAAAA;AAAR,OAAX,IAA8B,CAAC,MAAMR,OAAO,CAACiB,eAAR,EAAP,EAAkCC,UAAhE,EACEH,GAAG,CAACI,GAAJ,CAAQN,IAAR,EAAchC,QAAQ,CAACE,IAAT,CAAcyB,KAAd,CAAd;;AACF,aAAOO,GAAP;AACD,KALM,CAAP;AAMD;;AAEc,QAATK,SAAS,GAAe;AAC5B,WAAO,KAAKrB,YAAL,CAAkB,MAAOC,OAAP,IAA6C;AACpE,aAAOO,WAAW,CAAC,CAAC,MAAMP,OAAO,CAACoB,SAAR,EAAP,EAA4BZ,KAA7B,CAAlB;AACD,KAFM,CAAP;AAGD;;AAEDa,EAAAA,SAAS,GAAiD;AACxD,WAAO,IAAP;AACD;;AAEY,QAAPC,OAAO,GAAG;AACd,WAAO,KAAKvB,YAAL,CAAkB,MAAOC,OAAP,IAA6C;AACpE,aAAO,MAAMA,OAAO,CAACsB,OAAR,EAAb;AACD,KAFM,CAAP;AAGD;;AAEDC,EAAAA,QAAQ,GAAW;AACjB,WAAO,KAAKhC,QAAZ;AACD;;AA7DiI,C,CAgEpI;AACA;;;;;AACO,SAASe,iBAAT,CAA2BR,GAA3B,EAAkE;AACvE,QAAM0B,OAA2B,GAAG,EAApC;;AACA,QAAMC,UAAU,GAAIzB,OAAD,IAAuC;AACxDwB,IAAAA,OAAO,CAACE,IAAR,CAAa1B,OAAb;AACA,WAAOwB,OAAO,CAACG,MAAR,GAAiB,CAAxB;AACD,GAHD;;AAIA,QAAMnB,KAAK,GAAG,iCAAeV,GAAf,EAAoBU,KAAK,IAAI;AACzC,QAAIA,KAAK,YAAY3B,QAArB,EACE,OAAO;AAAE+C,MAAAA,CAAC,EAAEH,UAAU,CAACjB,KAAK,CAACd,QAAP;AAAf,KAAP;AACF,WAAO;AAAEmC,MAAAA,WAAW,EAAErB;AAAf,KAAP;AACD,GAJa,EAIX,IAAIsB,GAAJ,EAJW,CAAd;AAKA,SAAO;AAAEtB,IAAAA,KAAF;AAASgB,IAAAA;AAAT,GAAP;AACD;;AAEM,SAASjB,WAAT,CAAqBC,KAArB,EAA2D;AAChE,SAAO,uCAAqBA,KAArB,EAA4BuB,SAA5B,CAAP;AACD;;AAEM,SAASC,kBAAT,CAA4BC,KAA5B,EAA2CC,GAA3C,EAAuE;AAC5E,MAAID,KAAK,GAAGC,GAAZ,EACE,MAAM,IAAIC,KAAJ,CAAU,sGAAV,CAAN;AACH","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as channels from '../protocol/channels';\nimport { ChannelOwner } from './channelOwner';\nimport { parseSerializedValue, serializeValue } from '../protocol/serializers';\nimport * as api from '../../types/types';\nimport * as structs from '../../types/structs';\n\nexport class JSHandle<T = any> extends ChannelOwner<channels.JSHandleChannel, channels.JSHandleInitializer> implements api.JSHandle {\n  private _preview: string;\n\n  static from(handle: channels.JSHandleChannel): JSHandle {\n    return (handle as any)._object;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.JSHandleInitializer) {\n    super(parent, type, guid, initializer);\n    this._preview = this._initializer.preview;\n    this._channel.on('previewUpdated', ({preview}) => this._preview = preview);\n  }\n\n  async evaluate<R, Arg>(pageFunction: structs.PageFunctionOn<T, Arg, R>, arg?: Arg): Promise<R> {\n    return this._wrapApiCall(async (channel: channels.JSHandleChannel) => {\n      const result = await channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n      return parseResult(result.value);\n    });\n  }\n\n  async evaluateHandle<R, Arg>(pageFunction: structs.PageFunctionOn<T, Arg, R>, arg?: Arg): Promise<structs.SmartHandle<R>> {\n    return this._wrapApiCall(async (channel: channels.JSHandleChannel) => {\n      const result = await channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n      return JSHandle.from(result.handle) as any as structs.SmartHandle<R>;\n    });\n  }\n\n  async getProperty(propertyName: string): Promise<JSHandle> {\n    return this._wrapApiCall(async (channel: channels.JSHandleChannel) => {\n      const result = await channel.getProperty({ name: propertyName });\n      return JSHandle.from(result.handle);\n    });\n  }\n\n  async getProperties(): Promise<Map<string, JSHandle>> {\n    return this._wrapApiCall(async (channel: channels.JSHandleChannel) => {\n      const map = new Map<string, JSHandle>();\n      for (const { name, value } of (await channel.getPropertyList()).properties)\n        map.set(name, JSHandle.from(value));\n      return map;\n    });\n  }\n\n  async jsonValue(): Promise<T> {\n    return this._wrapApiCall(async (channel: channels.JSHandleChannel) => {\n      return parseResult((await channel.jsonValue()).value);\n    });\n  }\n\n  asElement(): T extends Node ? api.ElementHandle<T> : null {\n    return null as any;\n  }\n\n  async dispose() {\n    return this._wrapApiCall(async (channel: channels.JSHandleChannel) => {\n      return await channel.dispose();\n    });\n  }\n\n  toString(): string {\n    return this._preview;\n  }\n}\n\n// This function takes care of converting all JSHandles to their channels,\n// so that generic channel serializer converts them to guids.\nexport function serializeArgument(arg: any): channels.SerializedArgument {\n  const handles: channels.Channel[] = [];\n  const pushHandle = (channel: channels.Channel): number => {\n    handles.push(channel);\n    return handles.length - 1;\n  };\n  const value = serializeValue(arg, value => {\n    if (value instanceof JSHandle)\n      return { h: pushHandle(value._channel) };\n    return { fallThrough: value };\n  }, new Set());\n  return { value, handles };\n}\n\nexport function parseResult(value: channels.SerializedValue): any {\n  return parseSerializedValue(value, undefined);\n}\n\nexport function assertMaxArguments(count: number, max: number): asserts count {\n  if (count > max)\n    throw new Error('Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.');\n}\n"],"file":"jsHandle.js"}